package Qublog::Schema::Result::JournalEntry;
use Moose;

extends qw( Qublog::Schema::Result );
with qw( Qublog::Schema::Role::Itemized );

=head1 NAME

Qublog::Schema::Result::JournalEntry - groups timers together

=head1 DESCRIPTION

This is the top-most unit in the journal. Each journal entry is broken down into timers which have comments which have task logs which have tasks and task changes.

=head1 SCHEMA

=head2 id

The autogenerated ID column.

=head2 journal_session

The L<Qublog::Schema::Server::JournalSession> in which this entry is recorded.

=head2 name

The title of the entry.

=head2 start_time

The L<DateTime> timestamp for when this entry was initially started.

=head2 stop_time

The final L<DateTime> timestamp when the entry was last stopped. This will be C<undef> if the entry has a running timer.

=head2 primary_link

A URL to attach to the entry.

=head2 project

The L<Qublog::Schema::Result::Task> project this entry is for.

=head2 owner

The L<Qublog::Schema::Result::User> that created the entry.

=head2 journal_timers

A result set of L<Qublog::Schema::Result::JournalTimer>s that belong to this entry. There should always be at least one.

=head2 comments

A result set of L<Qublog::Schema::Result::Comemnt> objects that belong to this entry through the journal timers relationship.

=cut

__PACKAGE__->load_components(qw( InflateColumn::DateTime Core ));
__PACKAGE__->table('journal_entries');
__PACKAGE__->add_columns(
    id              => { data_type => 'int' },
    journal_session => { data_type => 'int' },
    name            => { data_type => 'text' },
    start_time      => { data_type => 'datetime', timezone => 'UTC' },
    stop_time       => { data_type => 'datetime', timezone => 'UTC' },
    primary_link    => { data_type => 'text' },
    project         => { data_type => 'int' },
    owner           => { data_type => 'int' },
);
__PACKAGE__->set_primary_key('id');
__PACKAGE__->belongs_to( journal_session => 'Qublog::Schema::Result::JournalSession' );
__PACKAGE__->belongs_to( project => 'Qublog::Schema::Result::Task' );
__PACKAGE__->belongs_to( owner => 'Qublog::Schema::Result::User' );
__PACKAGE__->has_many( journal_timers => 'Qublog::Schema::Result::JournalTimer', 'journal_entry' );
__PACKAGE__->has_many( journal_entry_tags => 'Qublog::Schema::Result::JournalEntryTag', 'journal_entry' );
__PACKAGE__->many_to_many( comments => journal_timer => 'comments' );
__PACKAGE__->many_to_many( tags => journal_entry_tags => 'tag' );
__PACKAGE__->resultset_class('Qublog::Schema::ResultSet::JournalEntry');

=head1 METHODS

=head2 new

Create a new journal entry. Sets the L</start_time> to the default value of now.

=cut

sub new {
    my ($class, $args) = @_;

    $args->{start_time} ||= Qublog::DateTime->now;

    return $class->next::method($args);
}

=head2 as_journal_item

No op. See L<Qublog::Schema::Role::Itemized>.

=cut

sub as_journal_item {}

=head2 list_journal_item_resultsets

Returns the timers associated with this entry.

See L<Qublog::Schema::Role::Itemized>.

=cut

sub list_journal_item_resultsets {
    my ($self, $options) = @_;

    return [] unless $options->{user};

    my $timers = $self->journal_timers;
    $timers->search({
        'journal_entry.owner' => $options->{user}->get_object->id,
    }, {
        join     => [ 'journal_entry' ],
        order_by => { -asc => 'start_time' },
        prefetch => 'journal_entry',
    });

    return [ $timers ];
}

=head2 hours

Returns a sum of all the hours of all the associated journal timers.

=cut

sub hours {
    my ($self, %args) = @_;

    my $hours = 0;
    my $timers = $self->journal_timers;
    $timers = $timers->search_by_running(0) if $args{stopped_only};
    while (my $timer = $timers->next) {
        $hours += $timer->hours;
    }
    return $hours;
}

=head2 is_running

Returns true if the journal entry has a running timer (i.e., L</stop_time> is C<undef>).

=cut

sub is_running {
    my $self = shift;
    return not defined $self->stop_time;
}

=head2 is_stopped

Returns true if the journal entry has no running timers (i.e., L</stop_time> is no C<undef>).

=cut

sub is_stopped {
    my $self = shift;
    return defined $self->stop_time;
}

=head2 start_timer

  $journal_entry->start_timer($c->now);

Stops all running timers for the current user. Starts a new L<Qublog::Schema::Result::JournalTimer> and marks this entry as running.

You may choose to pass your notion of what now is. If you do not, then C<< Qublog::DateTime->now >> will be used instead.

=cut

sub start_timer {
    my ($self, $now) = shift;
    my $schema = $self->result_source->schema;

    my $timer;
    $schema->txn_do(sub {
        my $running_entries 
            = $schema->resultset('JournalEntry')->search_by_running(1);
        $running_entries = $running_entries->search({
            id => { '!=', $self->id },
        });

        $now ||= Qublog::DateTime->now;
        while (my $running_entry = $running_entries->next) {
            $running_entry->stop_timer($now);
        }

        $timer = $schema->resultset('JournalTimer')->create({
            journal_entry => $self,
            start_time    => $now,
        });

        $self->stop_time(undef);
        $self->update;
    });

    return $timer;
}

=head2 stop_timer

  $journal_entry->stop_timer($c->now);

Stops all running timers on this entry. You may pass your notion of now, if you like. If you don't, C<< Qublog::DateTime->now >> will be used instead.

=cut

sub stop_timer {
    my ($self, $now) = shift;
    my $schema = $self->result_source->schema;

    my $timer;
    $schema->txn_do(sub {
        my $timers = $schema->resultset('JournalTimer')->search_by_running(1);

        $now ||= Qublog::DateTime->now;
        while ($timer = $timers->next) {
            $timer->stop_time($now);
            $timer->update;
        }

        $self->stop_time($now);
        $self->update;
    });
}

=head1 SEE ALSO

L<Qublog::Schema::ResultSet::JournalEntry>

=head1 AUTHOR

Andrew Sterling Hanenkamp, C<< <hanenkamp@cpan.org> >>

=head1 LICENSE

Qublog Personal/Professional Journaling
Copyright (C) 2009  Andrew Sterling Hanenkamp

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

1;
