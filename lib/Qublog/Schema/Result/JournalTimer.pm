package Qublog::Schema::Result::JournalTimer;
use Moose;
extends qw( Qublog::Schema::Result );

with qw( Qublog::Schema::Role::Itemized );

=head1 NAME

Qublog::Schema::Result::JournalTimer - timing your work

=head1 DESCRIPTION

A journal entry is broken down into one or more of these. This allows you to track work spent on a project in discrete parts of your day.

=head1 SCHEMA

=head2 id

The autogenerated ID column.

=head2 journal_entry

The L<Qublog::Schema::Result::JournalEntry> this timer belongs to.

=head2 start_time

The L<DateTime> timestamp of when the timer was started.

=head2 stop_time

The L<DateTime> timestamp of whent he timer was stopped. This will be C<undef> if the timer is currently running.

=head2 comments

A result set of the L<Qublog::Schema::Result::Comment>s attached to thsi timer.

=cut

__PACKAGE__->load_components(qw( InflateColumn::DateTime Core ));
__PACKAGE__->table('journal_timers');
__PACKAGE__->add_columns(
    id            => { data_type => 'int' },
    journal_entry => { data_type => 'int' },
    start_time    => { data_type => 'datetime', timezone => 'UTC' },
    stop_time     => { data_type => 'datetime', timezone => 'UTC' },
);
__PACKAGE__->set_primary_key('id');
__PACKAGE__->belongs_to( journal_entry => 'Qublog::Schema::Result::JournalEntry' );
__PACKAGE__->has_many( comments => 'Qublog::Schema::Result::Comment', 'journal_timer' );
__PACKAGE__->resultset_class('Qublog::Schema::ResultSet::JournalTimer');

=head1 METHODS

=head2 as_journal_item

Returns an item for the start and the stop.

See L<Qublog::Schema::Role::Itemized>

=cut

sub as_journal_item {
    my ($self, $options, $items) = @_;
    my $journal_entry = $self->journal_entry;

    my $collapse_start;
    for my $item_id (%$items) {
        next unless $item_id =~ /JournalTimer-\d+-stop/;
        next if $items->{$item_id}{collapse_start};

        if ($items->{$item_id}{timestamp} == $self->start_time) {
            $items->{$item_id}{collapse_start} = $self;
            $collapse_start++;
            last;
        }
    }

    my $id = 'JournalTimer-'.$self->id.'-';

    unless ($collapse_start) {
        my $start_name = $id.'start';
        $items->{$start_name} = {
            id             => $self->id,
            name           => $start_name,
            order_priority => $self->start_time->epoch * 10 + 1,
            timestamp      => $self->start_time,
            record         => $self,
        };
    }

    my $stop_name = $id.'stop';
    $items->{$stop_name} = {
        id             => $self->id,
        name           => $stop_name,
        order_priority => $self->start_time->epoch * 10 + 9,
        timestamp      => $self->stop_time || Qublog::DateTime->now,
        record         => $self,
    };
}

=head2 list_journal_item_resultsets

Returns a result set of comments.

See L<Qublog::Schema::Role::Itemized>.

=cut

sub list_journal_item_resultsets {
    my ($self, $options) = @_;

    return [] unless $options->{user};

    my $comments = $self->comments;
    $comments->search({
        'owner' => $options->{user}->get_object->id,
    }, {
        order_by => { -asc => 'created_on' },
    });

    return [ $comments ];
}

=head2 hours

This returns a decimal number representing the duration of the timer in hours. Months and days are translated roughly into hours. (And really, when will you be working on smoething that long anyway?) Minutes and seconds are translated into fractions of hours.

You may pass the C<stopped_only> option with a true value. If set and the timer is currently running, this method will return 0.

=cut

sub hours {
    my ($self, %args) = @_;

    return 0 if $args{stopped_only} and $self->is_running;

    my $start_time = $self->start_time;
    my $stop_time  = $self->stop_time || Qublog::DateTime->now;

    my $duration = $stop_time - $start_time;
    return $duration->delta_months  * 720 # assume, 30 day months... craziness
         + $duration->delta_days    * 24  # and 24 hour days
         + $duration->delta_minutes / 60
         + $duration->delta_seconds / 3600
         ;
}

=head2 is_running

Returns true if the timer is currently running (i.e., L</stop_time> is C<undef>).

=cut

sub is_running {
    my $self = shift;
    return not defined $self->stop_time;
}

=head2 is_stopped

Returns true if the timer is currently stopped (i.e., L</stop_time> is not C<undef>).

=cut

sub is_stopped {
    my $self = shift;
    return defined $self->stop_time;
}

=head1 SEE ALSO

L<Qublog::Schema::ResultSet::JournalTimer>

=head1 AUTHOR

Andrew Sterling Hanenkamp, C<< <hanenkamp@cpan.org> >>

=head1 LICENSE

Qublog Personal/Professional Journaling
Copyright (C) 2009  Andrew Sterling Hanenkamp

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

1;
