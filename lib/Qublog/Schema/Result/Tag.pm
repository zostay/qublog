package Qublog::Schema::Result::Tag;
use Moose;
extends qw( Qublog::Schema::Result );
with qw( Qublog::Schema::Role::Itemized );

use Number::RecordLocator;

=head1 NAME

Qublog::Schema::Result::Tag - tags help organize entries, comments, and tasks

=head1 DESCRIPTION

Tags help you organize your information.

=head1 SCHEMA

=head2 id

The autogenerated ID column.

=head2 name

The tag name.

=head2 tasks

A result set of L<Qublog::Schema::Result::Task> objects tagged by this tag.

=head2 comments

A result set of L<Qublog::Schema::Result::Comment> objects tagged by this tag.

=head2 journal_entries

A result set of L<Qublog::Schema::Result::JournalEntry> objects tagged by this tag.

=head2 task_tags

A result set of L<Qublog::Schema::Result::TaskTag> objects linked to this tag.

=head2 comment_tags

A result set of L<Qublog::Schema::Result::CommentTag> objects linked to this tag.

=head2 journal_entry_tags

A result set of L<Qublog::Schema::Result::JournalEntryTag> objects linked to this tag.

=cut

__PACKAGE__->load_components(qw( Core ));
__PACKAGE__->table('tags');
__PACKAGE__->add_columns(
    id   => { data_type => 'int' },
    name => { data_type => 'text' },
);
__PACKAGE__->set_primary_key('id');
__PACKAGE__->add_unique_constraint(
    name => [ qw( name ) ],
);
__PACKAGE__->has_many( task_tags => 'Qublog::Schema::Result::TaskTag', 'tag' );
__PACKAGE__->has_many( comment_tags => 'Qublog::Schema::Result::CommentTag', 'tag' );
__PACKAGE__->has_many( journal_entry_tags => 'Qublog::Schema::Result::JournalEntryTag', 'tag' );
__PACKAGE__->many_to_many( tasks => task_tags => 'task' );
__PACKAGE__->many_to_many( comments => comment_tags => 'comment' );
__PACKAGE__->many_to_many( journal_entries => journal_entry_tags => 'journal_entry' );

=head1 ATTRIBUTES

=head2 record_locator

This returns a L<Number::RecordLocator> object to use in creating auto-tags.

=cut

my $record_locator;
has record_locator => (
    is        => 'ro',
    isa       => 'Number::RecordLocator',
    required  => 1,
    lazy      => 1,
    default   => sub { $record_locator ||= Number::RecordLocator->new },
);

=head1 METHOD

=head2 new

Sets up the defaults for a new tag. You may pass an extra option, C<autotag>, when creating a tag. If given, the name argument does not need to be given and will be ignored if given. Instead, this will return a tag with an automatically assigned name using L<Qublog::Schema::Result::Sequence> and L<Number::RecordLocator>.

=cut

sub new {
    my ($class, $args) = @_;

    my $autotag = delete $args->{autotag};
    $args->{name} = '-' if $autotag;

    my $self = $class->next::method($args);

    my $schema = $self->result_source->schema;
    my $tags   = $schema->resultset('Tag');

    # TODO Hard coded sequence ID 1 is probably bad
    if ($autotag and $self) {
        $schema->txn_do(sub {
            my $sequence = $schema->resultset('Sequence')->find(1);
            
            my $autoname;
            $sequence->next_value(sub {
                $autoname = $self->record_locator->encode($_[0]);
                return 0 if ($tags->find({ name => $autoname }));
                return 1;
            });
            $sequence->update;

            $self->name($autoname);
        });
    }

    return $self;
}

=head2 as_journal_item

No op. See L<Qublog::Schema::Role::Itemized>.

=cut

sub as_journal_item { }

=head2 list_journal_item_resultsets

Returns the comments, tasks, and journal_entries tagged.

See L<Qublog::Schema::Role::Itemized>.

=cut

sub list_journal_item_resultsets {
    my ($self, $options) = @_;
    
    my @result_sets;
    push @result_sets, scalar $self->comments;
    push @result_sets, scalar $self->tasks;
    push @result_sets, scalar $self->journal_entries;

    return [ grep { $_ } @result_sets ];
}

=head1 AUTHOR

Andrew Sterling Hanenkamp, C<< <hanenkamp@cpan.org> >>

=head1 LICENSE

Qublog Personal/Professional Journaling
Copyright (C) 2009  Andrew Sterling Hanenkamp

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

1;
